<html>
<head>
    <link rel="stylesheet" type="text/css" href="./css/style.css" />

    <script src="./js/jquery.js" type="text/javascript"></script>
    <script src="./js/jquery.jscroll.js" type="text/javascript"></script>
    <script src="./js/rgraph/RGraph.common.core.js" type="text/javascript"></script>
    <script src="./js/rgraph/RGraph.common.tooltips.js" type="text/javascript"></script>
    <script src="./js/rgraph/RGraph.common.dynamic.js" type="text/javascript"></script>
    <script src="./js/rgraph/RGraph.common.effects.js" type="text/javascript"></script>
    <script src="./js/rgraph/RGraph.common.resizing.js" type="text/javascript"></script>
    <script src="./js/rgraph/RGraph.common.key.js" ></script>
    <script src="./js/rgraph/RGraph.bar.js" type="text/javascript"></script>
    <script src="./js/rgraph/RGraph.line.js" type="text/javascript"></script>
    <script src="./js/rgraph/RGraph.pie.js" type="text/javascript"></script>
    <script src="./js/rgraph/RGraph.scatter.js" type="text/javascript"></script>
    <script src="./js/rgraph/RGraph.drawing.rect.js" type="text/javascript"></script>

    <script type="text/javascript">
        // Colors from http://www.wowwiki.com/Class_colors
        var CLASS_COLORS = {
            'DEATHKNIGHT':  '#C41F3B',
            'DRUID':        '#FF7D0A',
            'HUNTER':       '#ABD473',
            'MAGE':         '#69CCF0',
            'MONK':         '#558A84',
            'PALADIN':      '#F58CBA',
            'PRIEST':       '#FFFFFF',
            'ROGUE':        '#FFF569',
            'SHAMAN':       '#0070DE',
            'WARLOCK':      '#9482C9',
            'WARRIOR':      '#C79C6E',
        };

        var DEFAULT_COLOR = '#808080';

        var entries = $ENTRIES$;
        var timestamps = $TIMETAMPS$;
        var character_names = $CHARACTER_NAMES$;
        var characters_to_ignore = $CHARACTERS_TO_IGNORE$;
        var characters_colors = $CHARACTERS_COLORS$;


        function getColor(name)
        {
            if (characters_colors[name] !== undefined)
                return characters_colors[name];
            else if (CLASS_COLORS[entries[name].class] !== undefined)
                return CLASS_COLORS[entries[name].class];

            return DEFAULT_COLOR;
        }


        function getScaleFactor(value)
        {
            var exponent = Math.floor(Math.log(value) / Math.log(10));
            return Math.pow(10, exponent);
        }


        function createRowLegend(character_name)
        {
            var row = document.createElement('tr');

            var color_cell = document.createElement('td');
            color_cell.innerHTML = '&nbsp;'
            color_cell.style.width = '25px';
            color_cell.style.backgroundColor = getColor(character_name);
            color_cell.style.borderWidth = '1px';
            color_cell.style.borderColor = 'black';
            color_cell.style.borderStyle = 'solid';
            row.appendChild(color_cell);

            var name_cell = document.createElement('td');
            name_cell.textContent = character_name;
            row.appendChild(name_cell);

            return row;
        }


        //--------------------------------------------------------------------------------
        // Iterate through all the sessions of each (enabled) characters and invoke
        // callbacks with the data found in the sessions
        //
        // Parameters:
        //     storage: User-provided map provided to each callback
        //     limit:   The number of sessions to iterate (always the most recent ones).
        //              If 'undefined', will iterate through all the sessions
        //     callbacks: A list of functions to call during the iterations
        //
        // The 'storage' object:
        //     The function will add the following fields to the 'storage' object:
        //        - timestamps: a list of the timestamps of the sessions
        //        - characters: a list of the names of the enabled characters
        //
        //     The callback functions are free to add any field they need to do their job.
        //
        // The callback functions:
        //     - onIterationStarted(storage):
        //              Called when the lists of timestamps and character names are ready
        //     - onCharacterStarted(storage, character_index):
        //              Called when the iteration over the sessions of a specific
        //              character begins
        //     - onData(storage, character_index, timestamp_index, values, previous_values):
        //              Called for each session of the character, with 'values' being the
        //              data of this character at the specified timestamp (can be null)
        //              and 'previous_values' the last known values for this character
        //              (can be null)
        //--------------------------------------------------------------------------------
        function iterateSessions(storage, limit, callbacks)
        {
            // Parameters handling
            if (limit === undefined)
                limit = timestamps.length;

            var offset = Math.max(timestamps.length - limit - 1, 1);

            // Store the timestamps of the concerned period
            storage.timestamps = timestamps.slice(offset);

            // Search the list of enabled characters and their last values before the period
            var last_values = new Array();
            var current_character = 0;
            storage.characters = new Array();
            for (var i = 0; i < character_names.length; ++i)
            {
                if (characters_to_ignore.indexOf(character_names[i]) !== -1)
                    continue;

                storage.characters[current_character] = character_names[i];

                last_values[current_character] = null;

                for (var j = offset - 1; j >= 0; --j)
                {
                    if (entries[character_names[i]].sessions[timestamps[j]] !== undefined)
                    {
                        last_values[current_character] = entries[character_names[i]].sessions[timestamps[j]];
                        break;
                    }
                }

                ++current_character;
            }

            callbacks.onIterationStarted(storage);

            // Iterate through the sessions
            for (var current_character = 0; current_character < storage.characters.length; ++current_character)
            {
                callbacks.onCharacterStarted(storage, current_character);

                var previous_values = last_values[current_character];

                for (var j = 0; j < storage.timestamps.length; ++j)
                {
                    var timestamp = storage.timestamps[j];

                    if (entries[storage.characters[current_character]].sessions[timestamp] !== undefined)
                    {
                        callbacks.onData(storage, current_character, j, entries[storage.characters[current_character]].sessions[timestamp], previous_values);
                        previous_values = entries[storage.characters[current_character]].sessions[timestamp];
                    }
                    else
                    {
                        callbacks.onData(storage, current_character, j, null, previous_values);
                    }
                }
            }
        }


        function getDateLabels(timestamps)
        {
            var current_year = null;
            var current_month = null;
            var labels = new Array();

            for (var j = 0; j < timestamps.length; ++j)
            {
                var date = new Date(timestamps[j] * 1000);

                labels[j] = '';

                if (timestamps.length < 31)
                    labels[j] = date.getUTCDate();

                if (current_month != date.getUTCMonth())
                {
                    labels[j] = labels[j] + '/' + (date.getUTCMonth() + 1);
                    current_month = date.getUTCMonth();
                }

                if (current_year != date.getUTCFullYear())
                {
                    labels[j] = labels[j] + '/' + date.getUTCFullYear();
                    current_year = date.getUTCFullYear();
                }
            }

            return labels;
        }


        function getLimitsOfCumulatedRows(values, default_max_value, default_min_value)
        {
            var max_value = undefined;
            var min_value = undefined;
            var sum = 0;

            if (default_max_value !== undefined)
                max_value = default_max_value;

            if (default_min_value !== undefined)
                min_value = default_min_value;

            for (var j = 0; j < values.length; ++j)
            {
                if (values[j] === null)
                    continue;

                var total = 0;

                if (values[j] instanceof Array)
                    total = getLimitsOfCumulatedRows(values[j], default_max_value, default_min_value).sum;
                else
                    total = values[j];

                if (max_value !== undefined)
                    max_value = Math.max(max_value, total);
                else
                    max_value = total;

                if (min_value !== undefined)
                    min_value = Math.min(min_value, total);
                else
                    min_value = total;

                sum += total;
            }

            return { max: max_value, min: min_value, sum: sum };
        }


        function flatten(values)
        {
            var result = new Array();
            for (var j = 0; j < values.length; ++j)
            {
                for (var i = 0; i < values[j].length; ++i)
                    result[j * values[j].length + i] = values[j][i];
            }

            return result;
        }


        function moneyAsHtml(gold)
        {
            var money_po = Math.floor(gold);
            var money_pa = Math.floor((gold * 100) % 100);
            var money_pc = Math.floor((gold * 10000) % 100);

            return '<span style="color: #FF9933">' + money_po + ' po</span> <span style="color: #777777">' +
                   money_pa + ' pa</span> <span style="color: #CC6600">' + money_pc + ' pc</span>';
        }


        function drawPerCharacterPlayTime()
        {
            // Prepare the data for the bar chart
            var storage = {
                data:             new Array(),
                colors:           new Array(),
                tooltips_stacked: new Array(),
            };

            iterateSessions(storage, 15, {
                onIterationStarted: function(storage) {
                        for (var i = 0; i < storage.timestamps.length; ++i)
                        {
                            storage.data[i]             = new Array();
                            storage.tooltips_stacked[i] = new Array();
                        }
                    },

                onCharacterStarted: function(storage, character_index) {
                        storage.colors[character_index] = getColor(storage.characters[character_index]);
                    },

                onData: function(storage, character_index, timestamp_index, values, previous_values) {
                        if ((values === null) || (previous_values === null))
                        {
                            storage.data[timestamp_index][character_index] = 0;
                            storage.tooltips_stacked[timestamp_index][character_index] = '';
                        }
                        else
                        {
                            var duration = values.played - previous_values.played;

                            storage.data[timestamp_index][character_index] = duration / 3600.0;

                            var seconds = duration % 60;
                            var minutes = ((duration - seconds) / 60) % 60;
                            var hours = (duration - minutes * 60 - seconds) / 3600;

                            var text = storage.characters[character_index] + ' (';

                            if (hours < 10)
                                text += '0';
                            text += hours + ':';

                            if (minutes < 10)
                                text += '0';
                            text += minutes + ':';

                            if (seconds < 10)
                                text += '0';
                            text += seconds + ')';

                            storage.tooltips_stacked[timestamp_index][character_index] = text;
                        }
                    },
                }
            );

            // Display the period covered by the graph
            var date_start = new Date(storage.timestamps[0] * 1000);
            var date_end = new Date(storage.timestamps[storage.timestamps.length - 1] * 1000);

            $('#graph_character_played_title').text(date_start.toLocaleDateString() + ' - ' + date_end.toLocaleDateString());

            // Compute the maximum value of the y-axis and the labels
            var labels = getDateLabels(storage.timestamps);
            var max_value = Math.ceil(getLimitsOfCumulatedRows(storage.data, 1).max);

            // Create the bar chart
            var gutterLeft = 50;

            var bar = new RGraph.Bar('graph_character_played', storage.data);
            bar.Set('chart.labels', labels);
            bar.Set('chart.labels.colors', ['black']);
            bar.Set('chart.tooltips', flatten(storage.tooltips_stacked));
            bar.Set('chart.gutter.left', gutterLeft);
            bar.Set('chart.background.barcolor1', 'white');
            bar.Set('chart.background.barcolor2', 'white');
            bar.Set('chart.background.grid', true);
            bar.Set('chart.colors', storage.colors);
            bar.Set('chart.grouping', 'stacked');
            bar.Set('chart.hmargin', 10);
            bar.Set('chart.strokestyle', '#000000');
            bar.Set('chart.ymax', max_value);
            bar.Set('chart.variant', '3d');
            bar.Set('chart.background.grid.autofit.numhlines', max_value);
            bar.Set('chart.background.grid.autofit.numvlines', storage.timestamps.length );
            bar.Set('chart.noyaxis', true);
            bar.Set('chart.ylabels', false);

            // Draws the extra axe. It's run whenever the bar object is drawn
            RGraph.AddCustomEventListener(bar, 'ondraw', function ()
                {
                    RGraph.DrawAxes(bar, {
                                          'axis.x': gutterLeft,
                                          'axis.color': 'black',
                                          'axis.text.color': 'black',
                                          'axis.max': max_value,
                                          'axis.numlabels': max_value,
                                          'axis.numticks': max_value * 2,
                                          'axis.min': 0,
                                          'axis.align': 'left',
                                          'axis.units.post': 'h',
                                          'axis.scale.decimals': 0,
                                         });
                }
            );

            bar.Draw();

            // Fill the legend panel
            var legend = $('#legend');
            for (var i = 0; i < storage.characters.length; ++i)
            {
                if (characters_to_ignore.indexOf(storage.characters[i]) !== -1)
                    continue;

                legend.append(createRowLegend(storage.characters[i]));
            }
        }


        function drawFortune()
        {
            // Prepare the data for the pie chart
            var storage = {
                data:   new Array(),
                colors: new Array(),
                labels: new Array(),
                total:  0,
            };

            iterateSessions(storage, 0, {
                onIterationStarted: function(storage) {
                        for (var i = 0; i < storage.characters.length; ++i)
                        {
                            storage.data[i]   = 0;
                            storage.labels[i] = '';
                        }
                    },

                onCharacterStarted: function(storage, character_index) {
                        storage.colors[character_index] = getColor(storage.characters[character_index]);
                    },

                onData: function(storage, character_index, timestamp_index, values, previous_values) {
                        if (values != null)
                        {
                            if (values.money !== undefined)
                                storage.data[character_index] = values.money / 10000;
                            else
                                storage.data[character_index] = 0;
                        }
                        else if (previous_values != null)
                        {
                            if (previous_values.money !== undefined)
                                storage.data[character_index] = previous_values.money / 10000;
                            else
                                storage.data[character_index] = 0;
                        }
                        else
                        {
                            storage.data[character_index] = 0;
                        }

                        storage.total += storage.data[character_index];

                        storage.labels[character_index] = storage.characters[character_index] + ': ' + moneyAsHtml(storage.data[character_index]);
                    },
                }
            );

            for (var i = 0; i < storage.data.length; ++i)
            {
                var percentage = Math.floor(100.0 * storage.data[i] / storage.total);
                storage.labels[i] += ' (' + percentage + '%)'
            }

            $('#graph_fortune_title').html('Total: ' + moneyAsHtml(storage.total));

            // Create the pie chart
            var pie = new RGraph.Pie('graph_fortune', storage.data);
            pie.Set('chart.tooltips', storage.labels);
            pie.Set('chart.linewidth', 2);
            pie.Set('chart.colors', storage.colors);
            pie.Set('chart.strokestyle', '#000000');
            pie.Draw();
        }


        function drawPerCharacterMoneyActivity()
        {
            // Prepare the data for the bar chart
            var storage = {
                data:     new Array(),
                incomes:  new Array(),
                expenses: new Array(),
                ok:       false,
            };

            iterateSessions(storage, 15, {
                onIterationStarted: function(storage) {
                        for (var i = 0; i < storage.timestamps.length; ++i)
                        {
                            storage.incomes[i]  = 0;
                            storage.expenses[i] = 0;
                        }
                    },

                onCharacterStarted: function(storage, character_index) {
                        storage.ok = false;
                    },

                onData: function(storage, character_index, timestamp_index, values, previous_values) {
                        if ((values != null) && (values.money !== undefined) &&
                            (previous_values != null) && (previous_values.money !== undefined))
                        {
                            if ((!storage.ok) && ((values.money == 0) || (previous_values.money == 0)))
                                return;

                            storage.ok = true;

                            var diff = (values.money - previous_values.money) / 10000;
                            if (diff == 0)
                                return;

                            var color = getColor(storage.characters[character_index]);

                            var box;
                            if (diff > 0)
                            {
                                box = [storage.incomes[timestamp_index],
                                       storage.incomes[timestamp_index],
                                       storage.incomes[timestamp_index] + diff / 2,
                                       storage.incomes[timestamp_index] + diff,
                                       storage.incomes[timestamp_index] + diff,
                                       color, color, 1.6
                                ];

                                storage.incomes[timestamp_index] += diff;
                            }
                            else
                            {
                                box = [storage.expenses[timestamp_index] + diff,
                                       storage.expenses[timestamp_index] + diff,
                                       storage.expenses[timestamp_index] + diff / 2,
                                       storage.expenses[timestamp_index],
                                       storage.expenses[timestamp_index],
                                       color, color, 1.6
                                ];

                                storage.expenses[timestamp_index] += diff;
                            }

                            storage.data[storage.data.length] = [
                                timestamp_index * 2 + 1,
                                box,
                                getColor(storage.characters[character_index]),
                                storage.characters[character_index] + ': -' + moneyAsHtml(Math.abs(diff)),
                            ];
                        }
                    },
                }
            );

            // Display the period covered by the graph
            var date_start = new Date(storage.timestamps[0] * 1000);
            var date_end = new Date(storage.timestamps[storage.timestamps.length - 1] * 1000);

            $('#graph_character_money_activity_title').text(date_start.toLocaleDateString() + ' - ' + date_end.toLocaleDateString());

            // Compute the maximum value of the y-axis and the labels
            var labels = getDateLabels(storage.timestamps);
            var max_value = Math.ceil(getLimitsOfCumulatedRows(storage.incomes, 1).max);
            var min_value = Math.floor(getLimitsOfCumulatedRows(storage.expenses, 1).min);
            var factor = getScaleFactor(max_value - min_value);
            max_value = Math.ceil(max_value / factor) * factor;
            min_value = Math.floor(min_value / factor) * factor;

            // Create the graph
            var gutterLeft = 80;
            var scatter = new RGraph.Scatter('graph_character_money_activity', storage.data);
            scatter.Set('chart.labels', labels);
            scatter.Set('chart.gutter.left', gutterLeft);
            scatter.Set('chart.background.barcolor1', 'white');
            scatter.Set('chart.background.barcolor2', 'white');
            scatter.Set('chart.background.grid', true);
            scatter.Set('chart.background.grid.autofit.numhlines', (max_value - min_value) / factor);
            scatter.Set('chart.background.grid.autofit.numvlines', storage.timestamps.length);
            scatter.Set('chart.hmargin', 10);
            scatter.Set('chart.strokestyle', '#000000');
            scatter.Set('chart.ymax', max_value);
            scatter.Set('chart.ymin', min_value);
            scatter.Set('chart.xmax', storage.timestamps.length * 2);
            scatter.Set('chart.noyaxis', true);
            scatter.Set('chart.ylabels', false);
            scatter.Set('chart.tickmarks', 'circle');

            // Draws the extra axe. It's run whenever the scatter object is drawn
            RGraph.AddCustomEventListener(scatter, 'ondraw', function ()
                {
                    RGraph.DrawAxes(scatter, {
                                          'axis.x': gutterLeft,
                                          'axis.color': 'black',
                                          'axis.text.color': 'black',
                                          'axis.max': max_value,
                                          'axis.numlabels': (max_value - min_value) / factor,
                                          'axis.numticks': ((max_value - min_value) / factor) * 2,
                                          'axis.min': min_value,
                                          'axis.align': 'left',
                                          'axis.units.post': ' po',
                                          'axis.scale.decimals': 0,
                                         });
                }
            );

            scatter.Draw();

            for (var i = 0; i < storage.timestamps.length; ++i)
            {
                var x = scatter.getXCoord(i * 2 + 0.2);
                var x2 = scatter.getXCoord((i + 1) * 2 - 0.2);
                var y0 = scatter.getYCoord(0);

                if (storage.incomes[i] > 0)
                {
                    var y = scatter.getYCoord(storage.incomes[i]);

                    var rect = new RGraph.Drawing.Rect('graph_character_money_activity', x, y, x2 - x, y0 - y);
                    rect.Set('chart.strokestyle', 'black');
                    rect.Set('chart.fillstyle', 'transparent');
                    rect.Set('chart.shadow', true);
                    rect.Draw();
                }

                if (storage.expenses[i] < 0)
                {
                    var y = scatter.getYCoord(storage.expenses[i]);

                    var rect = new RGraph.Drawing.Rect('graph_character_money_activity', x, y0, x2 - x, y - y0);
                    rect.Set('chart.strokestyle', 'black');
                    rect.Set('chart.fillstyle', 'transparent');
                    rect.Set('chart.shadow', true);
                    rect.Draw();
                }
            }

            var rect = new RGraph.Drawing.Rect('graph_character_money_activity', scatter.getXCoord(0), y0, scatter.getXCoord(storage.timestamps.length * 2) - scatter.getXCoord(0), 0);
            rect.Set('chart.strokestyle', 'black');
            rect.Set('chart.fillstyle', 'transparent');
            rect.Set('chart.shadow', false);
            rect.Draw();
        }


        function drawPerCharacterMoney()
        {
            // Prepare the data for the bar chart
            var storage = {
                data:             new Array(),
                colors:           new Array(),
                tooltips_stacked: new Array(),
            };

            iterateSessions(storage, 15, {
                onIterationStarted: function(storage) {
                        for (var i = 0; i < storage.timestamps.length; ++i)
                        {
                            storage.data[i]             = new Array();
                            storage.tooltips_stacked[i] = new Array();
                        }
                    },

                onCharacterStarted: function(storage, character_index) {
                        storage.colors[character_index] = getColor(storage.characters[character_index]);
                    },

                onData: function(storage, character_index, timestamp_index, values, previous_values) {
                        if (values != null)
                        {
                            if (values.money !== undefined)
                                storage.data[timestamp_index][character_index] = values.money / 10000;
                            else
                                storage.data[timestamp_index][character_index] = 0;
                        }
                        else if (previous_values != null)
                        {
                            if (previous_values.money !== undefined)
                                storage.data[timestamp_index][character_index] = previous_values.money / 10000;
                            else
                                storage.data[timestamp_index][character_index] = 0;
                        }
                        else
                        {
                            storage.data[timestamp_index][character_index] = 0;
                        }

                        storage.tooltips_stacked[timestamp_index][character_index] =
                                storage.characters[character_index] + ' (' +
                                moneyAsHtml(storage.data[timestamp_index][character_index]) + ')';
                    },
                }
            );

            // Compute the maximum value of the y-axis and the labels
            var labels = getDateLabels(storage.timestamps);
            var max_value = Math.ceil(getLimitsOfCumulatedRows(storage.data, 1).max);
            var factor = getScaleFactor(max_value);
            max_value = Math.ceil(max_value / factor) * factor;

            // Create the graph
            var bar_money = new RGraph.Bar('graph_character_money', storage.data);
            bar_money.Set('chart.labels', labels);
            bar_money.Set('chart.labels.colors', ['black']);
            bar_money.Set('chart.tooltips', flatten(storage.tooltips_stacked));
            bar_money.Set('chart.gutter.left', 80);
            bar_money.Set('chart.background.barcolor1', 'white');
            bar_money.Set('chart.background.barcolor2', 'white');
            bar_money.Set('chart.background.grid', true);
            bar_money.Set('chart.colors', storage.colors);
            bar_money.Set('chart.grouping', 'stacked');
            bar_money.Set('chart.hmargin', 10);
            bar_money.Set('chart.strokestyle', '#000000');
            bar_money.Set('chart.ymax', max_value);
            bar_money.Set('chart.variant', '3d');
            bar_money.Set('chart.units.post', ' po');
            bar_money.Set('chart.background.grid.autofit.numvlines', storage.timestamps.length );
            bar_money.Draw();

            // Fill the legend panel
            var legend = $('#legend_money');
            for (var i = 0; i < storage.characters.length; ++i)
            {
                if (characters_to_ignore.indexOf(storage.characters[i]) !== -1)
                    continue;

                legend.append(createRowLegend(storage.characters[i]));
            }
        }


        function drawTotalPlayTime()
        {
            // Prepare the data for the line charts
            var storage = {
                data_time:  new Array(),
                data_money: new Array(),
                last_money: null,
            };

            iterateSessions(storage, undefined, {
                onIterationStarted: function(storage) {
                        for (var i = 0; i < storage.timestamps.length; ++i)
                        {
                            storage.data_time[i]  = 0;
                            storage.data_money[i] = null;
                        }
                    },

                onCharacterStarted: function(storage, character_index) {
                        storage.last_money = null;
                    },

                onData: function(storage, character_index, timestamp_index, values, previous_values) {
                        if (values !== null)
                        {
                            if (previous_values !== null)
                            {
                                var duration = values.played - previous_values.played;
                                storage.data_time[timestamp_index] += duration / 3600.0;
                            }

                            if (values.money !== undefined)
                                storage.last_money = values.money / 10000;
                        }

                        if ((storage.last_money !== null) && (storage.last_money != 0))
                        {
                            if (storage.data_money[timestamp_index] !== null)
                                storage.data_money[timestamp_index] += storage.last_money;
                            else
                                storage.data_money[timestamp_index] = storage.last_money;
                        }
                    },
                }
            );

            // Compute the maximum and minimum values of the y-axis and the labels
            var labels = getDateLabels(storage.timestamps);

            var limits_time = getLimitsOfCumulatedRows(storage.data_time, 1);
            var limits_money = getLimitsOfCumulatedRows(storage.data_money, 1);

            var max_value_time = Math.ceil(limits_time.max);

            if (limits_money.max == limits_money.min) {
                limits_money.max = limits_money.max + 1000;
                limits_money.min = limits_money.min - 1000;
                if (limits_money.min < 0) {
                    limits_money.min = 0;
                }
            }

            var factor = getScaleFactor(limits_money.max - limits_money.min);

            var max_value_money = Math.ceil(limits_money.max / factor) * factor;
            var min_value_money = Math.floor(limits_money.min / factor) * factor;


            // Create the line charts
            var gutterLeft = 50;
            var gutterRight = 100;
            var gutterTop   = 25;

            var line1 = new RGraph.Line('graph_day_played', storage.data_time);
            line1.Set('chart.labels', labels);
            line1.Set('chart.gutter.right', gutterRight);
            line1.Set('chart.gutter.left', gutterLeft);
            line1.Set('chart.gutter.top', gutterTop);
            line1.Set('chart.background.barcolor1', 'white');
            line1.Set('chart.background.barcolor2', 'white');
            line1.Set('chart.background.grid.autofit.numhlines', max_value_time);
            line1.Set('chart.background.grid', true);
            line1.Set('chart.colors', ['red', 'blue']);
            line1.Set('chart.key', ['Time played', 'Money']);
            line1.Set('chart.key.position', 'gutter');
            line1.Set('chart.key.position.gutter.boxed', false);
            line1.Set('chart.key.position.x', 475);
            line1.Set('chart.linewidth', 2);
            line1.Set('chart.filled', false);
            line1.Set('chart.hmargin', 10);
            line1.Set('chart.units.post', 'h');
            line1.Set('chart.ymax', max_value_time);
            line1.Set('chart.noyaxis', true);
            line1.Set('chart.ylabels', false);
            line1.Draw();

            var line2 = new RGraph.Line('graph_day_played', storage.data_money);
            line2.Set('chart.gutter.left', 45);
            line2.Set('chart.gutter.right', gutterRight);
            line2.Set('chart.gutter.left', gutterLeft);
            line2.Set('chart.gutter.top', gutterTop);
            line2.Set('chart.background.grid', false);
            line2.Set('chart.colors', ['blue']);
            line2.Set('chart.linewidth', 2);
            line2.Set('chart.filled', false);
            line2.Set('chart.hmargin', 10);
            line2.Set('chart.units.post', 'po');
            line2.Set('chart.ymax', max_value_money);
            line2.Set('chart.ymin', min_value_money);
            line2.Set('chart.noaxes', true);
            line2.Set('chart.ylabels', false);

            // Draws the extra axes. It's run whenever the line2 object is drawn
            RGraph.AddCustomEventListener(line2, 'ondraw', function ()
                {
                    RGraph.DrawAxes(line1, {
                                            'axis.x': gutterLeft,
                                            'axis.color': 'red',
                                            'axis.text.color': 'red',
                                            'axis.max': max_value_time,
                                            'axis.numlabels': max_value_time,
                                            'axis.numticks': max_value_time * 2,
                                            'axis.min': 0,
                                            'axis.align': 'left',
                                            'axis.units.post': 'h',
                                            'axis.scale.decimals': 0,
                                           });
                    RGraph.DrawAxes(line2, {
                                            'axis.x': line1.canvas.width - gutterRight,
                                            'axis.color': 'blue',
                                            'axis.text.color': 'blue',
                                            'axis.max': max_value_money,
                                            'axis.min': min_value_money,
                                            'axis.numlabels': max_value_time,
                                            'axis.numticks': max_value_time * 2,
                                            'axis.align': 'right',
                                            'axis.units.post': ' po',
                                           });
                }
            );

            line2.Draw();
        }


        function drawCharactersPie(canvas_id, limit)
        {
            // Prepare the data for the pie chart
            var data = new Array();
            var labels = new Array();
            var colors = new Array();

            var current_character = 0;
            var total = 0;
            for (var i = 0; i < character_names.length; ++i)
            {
                if (characters_to_ignore.indexOf(character_names[i]) !== -1)
                    continue;

                var reference = 0;
                if ((limit !== null) && (limit < timestamps.length))
                {
                    var start_index = timestamps.length - limit - 1;

                    while (start_index >= 0)
                    {
                        var str_timestamp = Number(timestamps[start_index]).toString();

                        if (entries[character_names[i]].sessions[str_timestamp] !== undefined)
                        {
                            reference = entries[character_names[i]].sessions[str_timestamp].played;
                            break;
                        }

                        --start_index;
                    }

                    if (start_index < 0)
                    {
                        start_index = timestamps.length - limit;

                        while (start_index < timestamps.length)
                        {
                            var str_timestamp = Number(timestamps[start_index]).toString();

                            if (entries[character_names[i]].sessions[str_timestamp] !== undefined)
                            {
                                reference = entries[character_names[i]].sessions[str_timestamp].played;
                                break;
                            }

                            ++start_index;
                        }
                    }
                }

                var str_last_timestamp = Number(entries[character_names[i]].last).toString();
                var duration = entries[character_names[i]].sessions[str_last_timestamp].played - reference;

                if (duration > 0)
                {
                    data[current_character] = duration;
                    labels[current_character] = character_names[i];
                    colors[current_character] = getColor(character_names[i]);

                    total += duration;

                    ++current_character;
                }
            }

            for (var i = 0; i < data.length; ++i)
            {
                var percentage = Math.floor(100.0 * data[i] / total);
                labels[i] += ' (' + percentage + '%)'
            }

            // Create the pie chart
            var pie = new RGraph.Pie(canvas_id, data);
            pie.Set('chart.tooltips', labels);
            pie.Set('chart.linewidth', 2);
            pie.Set('chart.colors', colors);
            pie.Set('chart.strokestyle', '#000000');
            pie.Draw();
        }

    </script>
</head>
<body>

    <a href="https://github.com/Kanma/TitanPlayed">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub" />
    </a>

    <div id="container">
        <h2>Time played on each character</h2>
        <span id="graph_character_played_title" class="period"></span>
        <canvas id="graph_character_played" width="1000" height="600" style="cursor: default;"></canvas>


        <h2>Fortune</h2>
        <span id="graph_fortune_title" class="period"></span>
        <canvas id="graph_fortune" width="400" height="400" style="cursor: default;"></canvas>


        <h2>Money activity</h2>
        <span id="graph_character_money_activity_title" class="period"></span>
        <canvas id="graph_character_money_activity" width="1000" height="600" style="cursor: default;"></canvas>


        <h2>Daily activity</h2>
        <canvas id="graph_day_played" width="1000" height="600" style="cursor: default;"></canvas>


        <h2>Per-character percentage of time played</h2>
        <table>
            <tr>
                <td class="title">All time</td>
                <td class="title">Last 2 months</td>
                <td class="title">Last month</td>
            </tr>
            <tr>
                <td>
                    <canvas id="graph_characters_pie_all" width="300" height="300" style="cursor: default;"></canvas>
                </td>
                <td>
                    <canvas id="graph_characters_pie_2_months" width="300" height="300" style="cursor: default;"></canvas>
                </td>
                <td>
                    <canvas id="graph_characters_pie_1_month" width="300" height="300" style="cursor: default;"></canvas>
                </td>
            </tr>
            <tr>
                <td class="title">Last 2 weeks</td>
                <td class="title">Last week</td>
                <td class="title">Last 3 days</td>
            </tr>
            <tr>
                <td>
                    <canvas id="graph_characters_pie_2_weeks" width="300" height="300" style="cursor: default;"></canvas>
                </td>
                <td>
                    <canvas id="graph_characters_pie_1_week" width="300" height="300" style="cursor: default;"></canvas>
                </td>
                <td>
                    <canvas id="graph_characters_pie_3_days" width="300" height="300" style="cursor: default;"></canvas>
                </td>
            </tr>
        </table>
    </div>

    <div id="legend_scroller">
        <table id="legend"></table>
    </div>

    <span class="rgraph">Graphs generated with the  <a href="http://www.rgraph.net">RGraph library</a></span>

    <script type="text/javascript">
        window.onload = function ()
        {
            $("#legend_scroller").jScroll({ speed : "fast",
                                            top: 200,
                                          });

            drawPerCharacterPlayTime();
            drawFortune();
            drawPerCharacterMoneyActivity();
            drawTotalPlayTime();
            drawCharactersPie('graph_characters_pie_all', null);
            drawCharactersPie('graph_characters_pie_2_months', 60);
            drawCharactersPie('graph_characters_pie_1_month', 30);
            drawCharactersPie('graph_characters_pie_2_weeks', 14);
            drawCharactersPie('graph_characters_pie_1_week', 7);
            drawCharactersPie('graph_characters_pie_3_days', 3);
        }
    </script>
</html>
